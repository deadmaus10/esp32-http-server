<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <title>mm vs time — scrollable window (1–20 s) + összegzés</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    #wrap { max-width: 1100px; margin: auto; }
    canvas { width: 100%; height: 60vh; }
    .legend { margin: 8px 0 0 2px; font-size: 14px; color: #555; }
    .controls { display: grid; gap: 10px; grid-template-columns: 160px 1fr auto; align-items: center; margin: 12px 0 8px; }
    .controls label { font-size: 14px; color: #333; }
    .row { display: contents; }
    .val { min-width: 6ch; text-align: right; font-variant-numeric: tabular-nums; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 4px; }
    #status { font-size: 12px; color: #666; margin-top: 6px; }
    #fileInfo { font-size: 13px; color: #444; margin-top: 4px; }
    input[type="range"] { width: 100%; }
    .muted { color: #777; }

    /* --- Summary tables --------------------------------------------------- */
    #summaryWrap { margin-top: 20px; }
    h2 { font-size: 1.15rem; margin: 18px 0 8px; }
    table { width: 100%; border-collapse: collapse; margin: 8px 0 18px; }
    th, td { border: 1px solid #e6e6e6; padding: 8px 10px; font-size: 14px; }
    th { background: #fafafa; text-align: left; }
    td.num { text-align: right; font-variant-numeric: tabular-nums; }

    /* --- Options panel ---------------------------------------------------- */
    details { margin: 14px 0; }
    details > div { display: grid; gap: 10px; grid-template-columns: repeat(3, minmax(160px, 1fr)); }
    details label { display: flex; gap: 6px; align-items: center; font-size: 14px; }
    details input[type="number"] { width: 8ch; padding: 4px 6px; }

    /* --- Responsive upgrades --------------------------------------------- */
    #fileInfo { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    @media (max-width: 680px){ #fileInfo { white-space: normal; } }
    body { padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0); }
    canvas { width: 100%; height: 60vh; height: 60svh; }
    @media (max-width: 1200px) { body { margin: 20px; } #wrap { max-width: 100%; } canvas { height: 55vh; height: 55svh; } }
    @media (max-width: 900px) { h1 { font-size: 1.3rem; line-height: 1.2; } .legend { font-size: 13px; } .controls { grid-template-columns: 130px 1fr auto; gap: 8px; } canvas { height: 52vh; height: 52svh; } }
    @media (max-width: 680px) { body { margin: 14px; } .controls { grid-template-columns: 1fr; gap: 10px; } .row > label { grid-column: 1 / -1; margin-bottom: 4px; } .row > input[type="range"] { grid-column: 1 / -1; } .row > div { grid-column: 1 / -1; justify-self: end; } .val { font-size: 14px; } .legend { font-size: 12px; } #status { font-size: 11px; } canvas { height: 48vh; height: 48svh; } details > div { grid-template-columns: 1fr; } }
    input[type="range"] { width: 100%; height: 32px; background: transparent; -webkit-tap-highlight-color: transparent; touch-action: pan-y; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; border-radius: 999px; background: rgba(0,0,0,0.15); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 22px; height: 22px; border-radius: 50%; background: #555; border: none; margin-top: -8px; }
    input[type="range"]::-moz-range-track { height: 6px; border-radius: 999px; background: rgba(0,0,0,0.15); }
    input[type="range"]::-moz-range-thumb { width: 22px; height: 22px; border: none; border-radius: 50%; background: #555; }
    @media (prefers-color-scheme: dark) {
      input[type="range"]::-webkit-slider-runnable-track,
      input[type="range"]::-moz-range-track { background: rgba(255,255,255,0.25); }
      input[type="range"]::-webkit-slider-thumb,
      input[type="range"]::-moz-range-thumb { background: #ddd; }
      th { background: rgba(255,255,255,0.06); }
      th, td { border-color: rgba(255,255,255,0.15); }
    }
  </style>
</head>
<body>
<div id="wrap">
  <h1>mm vs elapsed time (s)</h1>

  <div class="legend">
    Tölts be egy CSV-t → állítsd a látható ablakot (1–20 s) → görgess végig a teljes mérésen.
  </div>

  <div class="controls">
    <div class="row">
      <label for="file">CSV file:</label>
      <input id="file" type="file" accept=".csv,text/csv" />
      <div id="fileInfo" class="muted">No file loaded</div>
    </div>

    <div class="row">
      <label for="win">Window length:</label>
      <input id="win" type="range" min="1" max="20" step="1" value="20" />
      <div><span class="val" id="winVal">20</span> s</div>
    </div>

    <div class="row">
      <label for="pos">Position:</label>
      <input id="pos" type="range" min="0" max="0" step="0.01" value="0" disabled />
      <div><span class="val" id="posStart">0.00</span> → <span class="val" id="posEnd">0.00</span> s</div>
    </div>
  </div>

  <canvas id="mmChart"></canvas>
  <div id="status"></div>

  <details id="opts">
    <summary>Észlelési beállítások (haladó)</summary>
    <div>
      <label>Min. fent-tartás (s)
        <input id="minHold" type="number" min="0" step="0.1" value="5.0" />
      </label>
      <label>Refrakter (s)
        <input id="minGap" type="number" min="0" step="0.1" value="0.75" />
      </label>
      <label>Top-only (≤ mm a globál max alatt)
        <input id="topTol" type="number" min="0" step="0.01" value="0.10" />
      </label>
    </div>
  </details>

  <!-- Summary tables -->
  <div id="summaryWrap" hidden>
    <h2>Fő eredmények</h2>
    <table id="mainStats">
      <thead>
        <tr>
          <th>Mutató</th>
          <th>Érték</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h2>Szenzoronként (a saját maxhoz viszonyítva)</h2>
    <table id="sensorStats">
      <thead>
        <tr>
          <th>Szenzor</th>
          <th>Max (mm)</th>
          <th>Min (mm)</th>
          <th>Tartomány (mm)</th>
          <th>Belépő küszöb (mm)</th>
          <th>Kilépő küszöb (mm)</th>
          <th>Észlelések (nyers)</th>
          <th>Észlelések (szűrt)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(() => {
  // --- UI elements ----------------------------------------------------------
  const $file = document.getElementById('file');
  const $fileInfo = document.getElementById('fileInfo');
  const $win = document.getElementById('win');
  const $winVal = document.getElementById('winVal');
  const $pos = document.getElementById('pos');
  const $posStart = document.getElementById('posStart');
  const $posEnd = document.getElementById('posEnd');
  const $status = document.getElementById('status');
  const $summaryWrap = document.getElementById('summaryWrap');
  const $mainStats = document.querySelector('#mainStats tbody');
  const $sensorStats = document.querySelector('#sensorStats tbody');
  const $minHold = document.getElementById('minHold');
  const $minGap = document.getElementById('minGap');
  const $topTol = document.getElementById('topTol');

  // --- State ----------------------------------------------------------------
  let chart = null;
  let all = [];          // [{t, mm0, mm1, ...}] sorted by t
  let mmKeys = [];       // ['mm0','mm1',...]
  let mmLabels = [];     // ["mm0", "mm1", ...]
  let tMin = 0, tMax = 0, dtMed = 0.01;

  // restore saved window length (1..20)
  let windowSeconds = clampInt(parseInt(localStorage.getItem('mm_window_seconds') || '20', 10), 1, 20);
  $win.value = String(windowSeconds);
  $winVal.textContent = String(windowSeconds);

  // --- Utils ----------------------------------------------------------------
  function status(m) { $status.textContent = m || ''; }
  function clampInt(n, lo, hi) { n = Number.isFinite(n) ? n : lo; return Math.min(hi, Math.max(lo, n)); }
  const fmt = (x, d=2) => (Number.isFinite(x) ? x.toFixed(d) : '—');

  function detectDelimiter(firstLine) {
    const c = (s, ch) => (s.match(new RegExp('\\' + ch, 'g')) || []).length;
    const cand = [{d:','},{d:';'},{d:'\t'}].map(o => ({...o, n:c(firstLine,o.d)}));
    cand.sort((a,b)=>b.n-a.n);
    return cand[0].n ? cand[0].d : ',';
  }

  function parseTimeSec(raw) {
    if (raw == null) return NaN;
    let s = String(raw).replace(/^\uFEFF/,'').trim().replace(/\u00A0/g,' ');
    if (!s) return NaN;
    const ms = s.match(/^(\d+(?:[.,]\d+)?)\s*ms$/i);
    if (ms) return parseFloat(ms[1].replace(',', '.')) / 1000;
    if (s.includes(':')) {
      s = s.replace(',', '.');
      const p = s.split(':').map(x=>x.trim());
      const toNum = x => parseFloat(x);
      if (p.length===2) { const mm = toNum(p[0]); const ss = toNum(p[1]); if (Number.isFinite(mm)&&Number.isFinite(ss)) return mm*60+ss; }
      if (p.length===3) { const hh = toNum(p[0]); const mm = toNum(p[1]); const ss = toNum(p[2]); if ([hh,mm,ss].every(Number.isFinite)) return hh*3600+mm*60+ss; }
      s = s.replace(/[^0-9.+-Ee]/g,''); const v = parseFloat(s); return Number.isFinite(v)?v:NaN;
    }
    s = s.replace(/[ '\u2007\u202F]/g,'').replace(',', '.');
    const v = parseFloat(s);
    return Number.isFinite(v) ? v : NaN;
  }

  function parseCSV(text) {
    const lines = text.replace(/^\uFEFF/,'').trim().split(/\r?\n/);
    if (!lines.length) return { header: [], rows: [], delim: ',' };
    const delim = detectDelimiter(lines.find(l=>l.trim().length) || lines[0]);
    const split = line => line.split(delim);
    const header = split(lines[0]).map(h=>h.trim());
    const rows = lines.slice(1).map(split);
    return { header, rows, delim };
  }

  function locateColumns(header) {
    const L = header.map(h=>h.toLowerCase());
    let iT = L.indexOf('t_s');
    if (iT === -1) iT = L.findIndex(h => h==='time' || h.includes('elapsed') || h==='time_s');
    if (iT === -1) iT = 0;
    const idxs = [];
    L.forEach((h,i)=>{ if (h==='mm' || /(^|[^a-z])mm\d*([^a-z]|$)/.test(h)) idxs.push(i); });
    return { iT, mmIdxs: idxs };
  }

  function toNumber(s, delim) {
    if (s == null) return NaN;
    s = String(s).trim();
    if (!s) return NaN;
    if (delim === ';' && s.indexOf('.') === -1 && s.indexOf(',') !== -1) {
      s = s.replace(',', '.');
    }
    s = s.replace(/[^\d+.\-eE]/g,'');
    return parseFloat(s);
  }

  function buildAll(text) {
    const { header, rows, delim } = parseCSV(text);
    const { iT, mmIdxs } = locateColumns(header);
    const labels = mmIdxs.map(i => header[i] || `mm${i}`);
    const arr = [];
    for (const r of rows) {
      const t = parseTimeSec(r[iT]);
      if (!Number.isFinite(t)) continue;
      const obj = { t };
      mmIdxs.forEach((idx, k) => {
        const v = toNumber(r[idx], delim);
        obj[`mm${k}`] = Number.isFinite(v) ? v : NaN;
      });
      arr.push(obj);
    }
    arr.sort((a,b)=>a.t-b.t);
    if (arr.length >= 3) {
      const dts = [];
      for (let i=1;i<arr.length;i++){ const dt=arr[i].t-arr[i-1].t; if (dt>0) dts.push(dt); }
      if (dts.length) {
        const s = dts.slice().sort((a,b)=>a-b);
        const med = s[Math.floor(s.length/2)];
        const thresh = Math.max(50*med, 5);
        for (let i=arr.length-1;i>=1;i--){
          if ((arr[i].t - arr[i-1].t) > thresh) { arr.splice(i); break; }
        }
      }
    }
    return { all: arr, mmLabels: labels };
  }

  function computeMeta(arr) {
    if (!arr.length) return { tMin:0, tMax:0, dtMed:0.01 };
    const tMin = arr[0].t, tMax = arr[arr.length-1].t;
    const dts = [];
    for (let i=1;i<arr.length;i++) { const d = arr[i].t - arr[i-1].t; if (d>0) dts.push(d); }
    let dtMed = 0.01;
    if (dts.length) {
      dts.sort((a,b)=>a-b);
      dtMed = dts[Math.floor(dts.length/2)];
    }
    return { tMin, tMax, dtMed };
  }

  function bisectLeft(arr, x) {
    let lo = 0, hi = arr.length;
    while (lo < hi) { const mid = (lo + hi) >> 1; if (arr[mid].t < x) lo = mid + 1; else hi = mid; }
    return lo;
  }

  function windowSeries(arr, start, lengthSec) {
    if (!arr.length) return { xMin:0, xMax:0, series:{}, yMin:undefined, yMax:undefined };
    const xMin = Math.max(tMin, Math.min(start, Math.max(tMin, tMax - lengthSec)));
    const xMax = Math.min(tMax, xMin + lengthSec);

    const i0 = bisectLeft(arr, xMin);
    const series = {};
    mmKeys.forEach(k => series[k] = []);
    let yMin = +Infinity, yMax = -Infinity;

    for (let i=i0; i<arr.length && arr[i].t <= xMax; i++) {
      const p = arr[i];
      mmKeys.forEach(k => {
        const y = p[k];
        if (Number.isFinite(y)) {
          series[k].push({ x: p.t, y });
          if (y < yMin) yMin = y;
          if (y > yMax) yMax = y;
        }
      });
    }

    if (!(yMin < yMax)) { yMin = undefined; yMax = undefined; } else {
      const pad = (yMax - yMin) * 0.05 || 1;
      yMin -= pad; yMax += pad;
    }
    return { xMin, xMax, series, yMin, yMax };
  }

  // --- Shot detection + summaries -----------------------------------------
  function smoothVec(vals, N=3) {
    if (N <= 1) return vals.slice();
    const out = new Array(vals.length);
    for (let i=0;i<vals.length;i++){
      let s=0,c=0; for (let k=-Math.floor(N/2); k<=Math.floor(N/2); k++){ const j=i+k; if (j>=0 && j<vals.length && Number.isFinite(vals[j])) { s+=vals[j]; c++; } }
      out[i] = c? s/c : vals[i];
    }
    return out;
  }

  function detectSegments(arr, key){
    const vals = arr.map(p => p[key]);
    let min = +Infinity, max = -Infinity;
    for (const v of vals) { if (Number.isFinite(v)) { if (v<min) min=v; if (v>max) max=v; } }
    const range = (Number.isFinite(max) && Number.isFinite(min)) ? (max - min) : 0;
    const entryTol = Math.max(0.3, 0.05 * range);
    const exitTol  = Math.max(0.8, 0.15 * range);
    const thrEntry = max - entryTol;
    let thrExit = max - exitTol; if (thrExit >= thrEntry) thrExit = thrEntry - 1e-9;

    const y = smoothVec(vals, 3);
    const segs = [];
    let inSeg=false, sIdx=-1;
    for (let i=0;i<y.length;i++){
      const above = Number.isFinite(y[i]) && (y[i] >= thrEntry);
      if (above && !inSeg){ inSeg=true; sIdx=i; }
      else if (!above && inSeg){ inSeg=false; segs.push([sIdx, i-1]); }
    }
    if (inSeg) segs.push([sIdx, y.length-1]);

    const merged=[];
    const t = arr.map(p=>p.t);
    for (const [s,e] of segs){
      if (!merged.length) { merged.push([s,e]); continue; }
      const [ps,pe] = merged[merged.length-1];
      const gap = t[s] - t[pe];
      if (gap <= 0.2){ merged[merged.length-1][1] = e; } else { merged.push([s,e]); }
    }

    const rich = merged.map(([s,e])=>{
      let peak=-Infinity; for (let i=s;i<=e;i++){ if (Number.isFinite(y[i]) && y[i] > peak) peak=y[i]; }
      return { start: t[s], end: t[e], dur: t[e]-t[s], peak, min, max, range, thrEntry, thrExit };
    });
    const rawCount = rich.length;

    const tolMm = Math.max(0, parseFloat($topTol.value)||0);
    const minHold = Math.max(0, parseFloat($minHold.value)||0);
    let filtered = rich.filter(seg => (seg.max - seg.peak) <= tolMm && seg.dur >= minHold);

    const minGap = Math.max(0, parseFloat($minGap.value)||0);
    const kept = [];
    for (const seg of filtered){
      if (!kept.length || (seg.start - kept[kept.length-1].start) > minGap) kept.push(seg);
    }

    return { min, max, range, thrEntry, thrExit, rawCount, segs: kept, times: kept.map(s=>s.start) };
  }

  function mergeShotTimes(perSensorTimes, dedupWindowSec = 1.0) {
    const allTimes = perSensorTimes.flat().slice().sort((a,b)=>a-b);
    const merged = [];
    for (const t of allTimes) {
      if (!merged.length || (t - merged[merged.length-1]) > dedupWindowSec) merged.push(t);
    }
    return merged;
  }

  function percentile(arr, p) {
    if (!arr.length) return NaN; if (p<=0) return arr[0]; if (p>=100) return arr[arr.length-1];
    const a = arr.slice().sort((x,y)=>x-y);
    const idx = (p/100)*(a.length-1);
    const lo = Math.floor(idx), hi = Math.ceil(idx);
    if (lo === hi) return a[lo];
    const t = idx - lo; return a[lo]*(1-t) + a[hi]*t;
  }

  function computeAndRenderSummary() {
    if (!all.length || !mmKeys.length) { $summaryWrap.hidden = true; return; }

    const per = mmKeys.map(k => detectSegments(all, k));
    const perTimes = per.map(o => o.times);
    const merged = mergeShotTimes(perTimes, 1.0);

    const intervals = merged.length >= 2 ? merged.slice(1).map((t,i)=>t-merged[i]) : [];
    const count = merged.length;
    const duration = count ? (merged[merged.length-1] - merged[0]) : 0;
    const spm = duration > 0 ? (count / (duration/60)) : NaN;

    const rows = [
      ['Összes lövés (szűrt)', count.toString()],
      ['Időtartam (s)', fmt(duration, 2)],
      ['Ütem (lövések/perc)', Number.isFinite(spm) ? spm.toFixed(2) : '—'],
      ['Két lövés közti idő — átlag (s)', intervals.length? fmt(intervals.reduce((a,b)=>a+b,0)/intervals.length,3):'—'],
      ['Két lövés közti idő — medián (s)', intervals.length? fmt(percentile(intervals,50),3):'—'],
      ['Min / 5% / 95% / Max (s)', intervals.length? `${fmt(Math.min(...intervals),3)} / ${fmt(percentile(intervals,5),3)} / ${fmt(percentile(intervals,95),3)} / ${fmt(Math.max(...intervals),3)}`:'—'],
      ['Beállítások', `minHold=${fmt(parseFloat($minHold.value)||0,1)} s · refractory=${fmt(parseFloat($minGap.value)||0,1)} s · topTol=${fmt(parseFloat($topTol.value)||0,2)} mm`]
    ];
    $mainStats.innerHTML = rows.map(([k,v])=>`<tr><td>${k}</td><td class="num">${v}</td></tr>`).join('');

    $sensorStats.innerHTML = per.map((o, i)=>{
      const nm = (mmLabels[i] || mmKeys[i]);
      const shotsRaw = o.rawCount;
      const shotsFilt = o.segs.length;
      return `<tr>
        <td>${nm}</td>
        <td class="num">${fmt(o.max,3)}</td>
        <td class="num">${fmt(o.min,3)}</td>
        <td class="num">${fmt(o.range,3)}</td>
        <td class="num">${fmt(o.thrEntry,3)}</td>
        <td class="num">${fmt(o.thrExit,3)}</td>
        <td class="num">${shotsRaw}</td>
        <td class="num">${shotsFilt}</td>
      </tr>`;
    }).join('');

    $summaryWrap.hidden = false;
  }

  // --- Chart ---------------------------------------------------------------
  function initChart() {
    const ctx = document.getElementById('mmChart').getContext('2d');
    const datasets = mmKeys.map((k,i) => ({
      label: mmLabels[i] || k,
      data: [],
      borderWidth: 1,
      tension: 0,
      spanGaps: true,
      pointRadius: 0,
      ...(i % 2 ? { borderDash: [6,4] } : {})
    }));
    chart = new Chart(ctx, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        animation: false,
        parsing: false,
        normalized: true,
        plugins: {
          title: { display: true, text: 'Elapsed time (s) vs mm' },
          legend: { display: datasets.length > 1 },
          tooltip: {
            mode: 'nearest',
            intersect: false,
            callbacks: {
              title: items => `t = ${items[0].raw.x.toFixed(3)} s`,
              label: item => `${item.dataset.label}: ${Number.isFinite(item.raw.y) ? item.raw.y.toFixed(2) : '—'} mm`
            }
          },
          decimation: { enabled: true, algorithm: 'lttb' }
        },
        elements: { line: { tension: 0 } },
        scales: {
          x: { type: 'linear', title: { display: true, text: 'Elapsed time (s)' }, ticks: { maxTicksLimit: 12 } },
          y: { title: { display: true, text: 'mm' }, ticks: { maxTicksLimit: 8 } }
        },
        interaction: { mode: 'nearest', intersect: false }
      }
    });
  }

  function updateChartWindow(start, lengthSec) {
    if (!chart || !all.length) return;
    const { xMin, xMax, series, yMin, yMax } = windowSeries(all, start, lengthSec);

    chart.data.datasets.forEach((ds, i) => {
      const key = mmKeys[i];
      const pts = series[key] || [];
      ds.data = pts;
      ds.pointRadius = pts.length < 200 ? 1.5 : 0;
    });

    const xs = chart.options.scales.x, ys = chart.options.scales.y;
    xs.min = xMin; xs.max = xMax;
    if (yMin !== undefined && yMax !== undefined) { ys.min = yMin; ys.max = yMax; } else { delete ys.min; delete ys.max; }

    $posStart.textContent = fmt(xMin, 2);
    $posEnd.textContent = fmt(xMax, 2);

    chart.update('none');
  }

  function configurePositionSlider() {
    const lengthSec = windowSeconds;
    const maxStart = Math.max(tMin, tMax - lengthSec);
    $pos.min = String(tMin);
    $pos.max = String(maxStart);
    const step = Math.max(0.001, +(dtMed.toFixed(3)));
    $pos.step = String(step);

    const saved = parseFloat(localStorage.getItem('mm_pos_seconds') || String(maxStart));
    let posVal = (Number.isFinite(saved) ? saved : tMin);
    posVal = Math.min(maxStart, Math.max(tMin, posVal));
    $pos.value = String(posVal);
    $pos.disabled = false;

    updateChartWindow(posVal, lengthSec);
    status(`Loaded ${all.length.toLocaleString()} rows · duration ${fmt(tMax - tMin,2)} s · median Δt ${fmt(dtMed,3)} s`);
  }

  // --- Event handlers -------------------------------------------------------
  $file.addEventListener('change', () => {
    const f = $file.files?.[0];
    if (!f) return;
    $fileInfo.textContent = `${f.name} (${(f.size/1024).toFixed(1)} KB)`;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const text = String(ev.target.result || '');
        ({ all, mmLabels } = buildAll(text));
        if (!all.length) throw new Error('No data rows parsed.');
        mmKeys = Object.keys(all[0]).filter(k => k.startsWith('mm'));
        if (!mmKeys.length) throw new Error('No mm columns detected (need "mm", "mm0", etc.).');
        ({ tMin, tMax, dtMed } = computeMeta(all));

        if (!chart) initChart();
        configurePositionSlider();
        computeAndRenderSummary();
      } catch (e) {
        console.error(e);
        status(`Error: ${e.message}`);
        $summaryWrap.hidden = true;
      }
    };
    reader.readAsText(f);
  });

  $win.addEventListener('input', () => {
    windowSeconds = clampInt(parseInt($win.value, 10), 1, 20);
    $winVal.textContent = String(windowSeconds);
    localStorage.setItem('mm_window_seconds', String(windowSeconds));
    if (!all.length) return;
    configurePositionSlider();
  });

  let raf = 0;
  $pos.addEventListener('input', () => {
    if (!all.length) return;
    const pos = parseFloat($pos.value);
    if (raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      updateChartWindow(pos, windowSeconds);
      localStorage.setItem('mm_pos_seconds', String(pos));
    });
  });

  // Recalc summary when detection params change
  [$minHold, $minGap, $topTol].forEach(inp => {
    inp.addEventListener('change', () => { if (all.length) computeAndRenderSummary(); });
  });
})();
</script>
</body>
</html>
