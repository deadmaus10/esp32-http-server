<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>mm vs time (window slider)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    #wrap { max-width: 1100px; margin: auto; }
    canvas { width: 100%; height: 60vh; }
    .legend { margin: 8px 0 0 2px; font-size: 14px; color: #555; }
    .controls { display: flex; align-items: center; gap: 12px; margin: 10px 0 6px; }
    .controls label { font-size: 14px; color: #333; }
    .value { min-width: 2ch; display: inline-block; text-align: right; font-variant-numeric: tabular-nums; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 4px; }
    #status { font-size: 12px; color: #666; margin-top: 6px; }
  </style>
</head>
<body>
<div id="wrap">
  <h1>mm vs elapsed time (s)</h1>
  <p class="legend">
    Source: <code>sess_2025-09-21_22-20-22.csv</code> · Refresh: <strong>1s</strong>
  </p>

  <div class="controls">
    <label for="win">Window (seconds): <span class="value" id="winVal">20</span>s</label>
    <input id="win" type="range" min="1" max="20" step="1" value="20" />
  </div>

  <canvas id="mmChart"></canvas>
  <div id="status"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(() => {
  const CSV_FILE = 'sess_2025-09-21_22-20-22.csv';
  const REFRESH_MS = 1000;
  const MIN_POINTS = 2;
  const FALLBACK_LAST_N = 500;

  let chart = null;
  let fetching = false;
  const $status = document.getElementById('status');
  const $win = document.getElementById('win');
  const $winVal = document.getElementById('winVal');

  // restore saved window length (1..20), default 20
  const saved = parseInt(localStorage.getItem('mm_window_seconds') || '20', 10);
  let windowSeconds = Number.isFinite(saved) ? Math.min(20, Math.max(1, saved)) : 20;
  $win.value = String(windowSeconds);
  $winVal.textContent = String(windowSeconds);

  $win.addEventListener('input', () => {
    windowSeconds = parseInt($win.value, 10);
    if (!Number.isFinite(windowSeconds)) windowSeconds = 20;
    windowSeconds = Math.min(20, Math.max(1, windowSeconds));
    $winVal.textContent = String(windowSeconds);
    localStorage.setItem('mm_window_seconds', String(windowSeconds));
    // Re-render immediately using the new window (does not cancel the poll loop)
    tick();
  });

  const status = (m) => $status.textContent = m || '';

  // --- CSV parsing + time handling ---
  function detectDelimiter(firstLine) {
    const c = (s, ch) => (s.match(new RegExp('\\' + ch, 'g')) || []).length;
    const candidates = [{d:','},{d:';'},{d:'\t'}].map(o => ({...o, n:c(firstLine,o.d)}));
    candidates.sort((a,b)=>b.n-a.n);
    return candidates[0].n ? candidates[0].d : ',';
  }

  function parseTimeSec(raw) {
    if (raw == null) return NaN;
    let s = String(raw).replace(/^\uFEFF/, '').trim().replace(/\u00A0/g, ' ');
    if (!s) return NaN;

    const ms = s.match(/^(\d+(?:[.,]\d+)?)\s*ms$/i);
    if (ms) return parseFloat(ms[1].replace(',', '.')) / 1000;

    if (s.includes(':')) {
      s = s.replace(',', '.');
      const parts = s.split(':');
      const toNum = x => parseFloat(String(x).trim());
      if (parts.length === 2) { const mm = toNum(parts[0]); const ss = toNum(parts[1]); if (Number.isFinite(mm)&&Number.isFinite(ss)) return mm*60 + ss; }
      if (parts.length === 3) { const hh = toNum(parts[0]); const mm = toNum(parts[1]); const ss = toNum(parts[2]); if ([hh,mm,ss].every(Number.isFinite)) return hh*3600 + mm*60 + ss; }
      s = s.replace(/[^0-9.+-Ee]/g, '');
      const v = parseFloat(s); return Number.isFinite(v) ? v : NaN;
    }

    s = s.replace(/[ '\u2007\u202F]/g, '').replace(',', '.');
    const v = parseFloat(s);
    return Number.isFinite(v) ? v : NaN;
  }

  function parseCSV(text) {
    const lines = text.replace(/^\uFEFF/, '').trim().split(/\r?\n/);
    if (!lines.length) return { header: [], rows: [], delim: ',' };
    const delim = detectDelimiter(lines.find(l => l.trim().length) || lines[0]);
    const split = (line) => line.split(delim);
    const header = split(lines[0]).map(h => h.trim());
    const rows = lines.slice(1).map(split);
    return { header, rows, delim };
  }

  function locateColumns(header) {
    const L = header.map(h => h.toLowerCase());
    let iT = L.indexOf('t_s');
    if (iT === -1) iT = L.findIndex(h => h === 'time' || h.includes('elapsed') || h === 'time_s');
    if (iT === -1) iT = 0;

    const mmIdxs = [];
    L.forEach((h,i)=>{ if (h === 'mm' || /(^|[^a-z])mm\d*([^a-z]|$)/.test(h)) mmIdxs.push(i); });
    return { iT, mmIdxs };
  }

  function buildSeries(text) {
    const { header, rows } = parseCSV(text);
    const { iT, mmIdxs } = locateColumns(header);
    const labels = mmIdxs.map(i => header[i] || `mm${i}`);

    const all = [];
    for (const r of rows) {
      const t = parseTimeSec(r[iT]);
      if (!Number.isFinite(t)) continue;
      const obj = { t };
      mmIdxs.forEach((idx, k) => {
        const val = parseFloat(String(r[idx]).replace(',', '.').replace(/[^\d.+-Ee]/g, ''));
        obj[`mm${k}`] = Number.isFinite(val) ? val : NaN;
      });
      all.push(obj);
    }
    all.sort((a,b)=>a.t - b.t);
    return { all, labels };
  }

  function trimTimeOutlierTail(all) {
    if (all.length < 3) return all;
    const dts = [];
    for (let i=1;i<all.length;i++) {
      const dt = all[i].t - all[i-1].t;
      if (dt > 0) dts.push(dt);
    }
    if (!dts.length) return all;
    const sorted = dts.slice().sort((a,b)=>a-b);
    const med = sorted[Math.floor(sorted.length/2)];
    const thresh = Math.max(50*med, 5);
    for (let i=all.length-1;i>=1;i--) {
      const dt = all[i].t - all[i-1].t;
      if (dt > thresh) return all.slice(0, i);
    }
    return all;
  }

  function windowAndScale(all, windowSec) {
    if (!all.length) return { series:{}, order:[], xMin:undefined, xMax:undefined, yMin:undefined, yMax:undefined };
    const mmKeys = Object.keys(all[0]).filter(k => k.startsWith('mm'));
    const lastT = all[all.length-1].t;
    let xMin = Math.max(0, lastT - windowSec);
    let W = all.filter(p => p.t >= xMin);
    if (W.length < MIN_POINTS) {
      W = all.slice(-FALLBACK_LAST_N);
      xMin = W.length ? W[0].t : lastT - windowSec;
    }
    const series = {}; mmKeys.forEach(k => series[k] = []);
    let yMin = +Infinity, yMax = -Infinity;
    for (const p of W) {
      mmKeys.forEach(k => {
        const y = p[k];
        if (Number.isFinite(y)) {
          series[k].push({ x: p.t, y });
          if (y < yMin) yMin = y;
          if (y > yMax) yMax = y;
        }
      });
    }
    const xMax = W.length ? W[W.length-1].t : lastT;
    if (!(yMin < yMax)) { yMin = undefined; yMax = undefined; } else {
      const pad = (yMax - yMin) * 0.05 || 1;
      yMin -= pad; yMax += pad;
    }
    if (!(Number.isFinite(xMin) && Number.isFinite(xMax) && xMax > xMin)) { xMin = undefined; xMax = undefined; }
    return { series, order:mmKeys, xMin, xMax, yMin, yMax };
  }

  async function fetchCSV() {
    const res = await fetch(`${CSV_FILE}?t=${Date.now()}`, { cache: 'no-store' });
    if (!res.ok) throw new Error('CSV fetch failed');
    return res.text();
  }

  async function tick() {
    if (fetching) return;
    fetching = true;
    try {
      const text = await fetchCSV();
      let { all, labels } = buildSeries(text);
      const before = all.length ? all[all.length-1].t : NaN;
      all = trimTimeOutlierTail(all);
      const after = all.length ? all[all.length-1].t : NaN;

      const { series, order, xMin, xMax, yMin, yMax } = windowAndScale(all, windowSeconds);
      const datasets = order.map((k, i) => {
        const lbl = labels[i] || k;
        const pts = series[k] || [];
        return {
          label: lbl,
          data: pts,
          borderWidth: 1,
          tension: 0,
          spanGaps: true,
          pointRadius: pts.length < 200 ? 1.5 : 0,
          ...(i % 2 ? { borderDash: [6,4] } : {})
        };
      });

      const info = `Window: last ${windowSeconds}s · lastT raw=${isFinite(before)?before.toFixed(3):'—'}s → trimmed=${isFinite(after)?after.toFixed(3):'—'}s · X: ${xMin??'auto'}→${xMax??'auto'} · series: ${datasets.map(d=>d.label).join(', ')}`;
      status(info);

      if (!chart) {
        if (!datasets.length) throw new Error('No mm columns detected (need "mm", "mm0", etc.).');
        const ctx = document.getElementById('mmChart').getContext('2d');
        chart = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            animation: false,
            parsing: false,
            plugins: {
              title: { display: true, text: 'Elapsed time (s) vs mm' },
              legend: { display: datasets.length > 1 },
              tooltip: {
                mode: 'nearest',
                intersect: false,
                callbacks: {
                  title: items => `t = ${items[0].raw.x.toFixed(3)} s`,
                  label: item => `${item.dataset.label}: ${Number.isFinite(item.raw.y) ? item.raw.y.toFixed(2) : '—'} mm`
                }
              },
              decimation: { enabled: true, algorithm: 'lttb' }
            },
            elements: { line: { tension: 0 } },
            scales: {
              x: { type: 'linear', ...(xMin!==undefined?{min:xMin}:{}) , ...(xMax!==undefined?{max:xMax}:{}) , title:{display:true,text:'Elapsed time (s)'}, ticks:{maxTicksLimit:12} },
              y: { ...(yMin!==undefined?{min:yMin}:{}) , ...(yMax!==undefined?{max:yMax}:{}) , title:{display:true,text:'mm'}, ticks:{maxTicksLimit:8} }
            },
            interaction: { mode: 'nearest', intersect: false }
          }
        });
        return;
      }

      chart.data.datasets = datasets;
      const xs = chart.options.scales.x, ys = chart.options.scales.y;
      if (xMin!==undefined && xMax!==undefined) { xs.min = xMin; xs.max = xMax; } else { delete xs.min; delete xs.max; }
      if (yMin!==undefined && yMax!==undefined) { ys.min = yMin; ys.max = yMax; } else { delete ys.min; delete ys.max; }
      chart.update('none');
    } catch (e) {
      console.warn(e);
      status(`Error: ${e.message}`);
    } finally {
      fetching = false;
    }
  }

  tick();
  setInterval(tick, REFRESH_MS);
})();
</script>
</body>
</html>
